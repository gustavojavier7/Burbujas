<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CryptoBubbles: Monitor de Liquidaciones</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #1a1a1a;
      color: #fff;
      margin: 0;
      padding: 0;
      overflow: hidden; /* Evitar scrollbars */
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* HEADER / TICKER */
    .header-info {
      background-color: #252525;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
      z-index: 10;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    .status-dot {
      height: 10px;
      width: 10px;
      background-color: #bbb;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
    }
    .status-connected { background-color: #4CAF50; box-shadow: 0 0 5px #4CAF50;}
    .status-disconnected { background-color: #f44336; }

    /* CONTENEDOR DE BURBUJAS */
    #bubble-chart {
      flex-grow: 1;
      width: 100%;
      height: 100%;
      position: relative;
      background: radial-gradient(circle at center, #2a2a2a 0%, #111 100%);
    }

    /* ESTILOS SVG */
    text {
      font-family: sans-serif;
      text-anchor: middle;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    .bubble-label {
      font-weight: bold;
      fill: white;
      font-size: 14px;
    }
    .bubble-value {
      fill: #eee;
      font-size: 10px;
      margin-top: 5px;
    }
    circle {
      stroke: #fff;
      stroke-width: 1px;
      stroke-opacity: 0.3;
      transition: fill 0.5s ease;
      cursor: pointer;
    }
    circle:hover {
      stroke-opacity: 0.8;
      stroke-width: 2px;
    }

    /* PANEL DE DETALLE FLOTANTE (Opcional) */
    #details-panel {
      position: absolute;
      top: 70px;
      right: 20px;
      width: 250px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      display: none;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div class="header-info">
    <div>
      <span id="connection-status" class="status-dot"></span>
      <strong>Binance Liq. Stream</strong>
    </div>
    <div style="font-size: 0.9em; color: #aaa;">
      Rojo = Long REKT (Venta forzada) | Verde = Short REKT (Compra forzada)
    </div>
  </div>

  <div id="bubble-chart"></div>
  
  <div id="details-panel">
    <h3 id="panel-symbol">SYMBOL</h3>
    <p>Total Liq: <span id="panel-total">0</span></p>
  </div>

  <script>
    // --- CONFIGURACIÓN ---
    const WS_URL = 'wss://fstream.binance.com/ws/!forceOrder@arr';
    const DECAY_RATE = 0.995; // Qué tan rápido se encogen las burbujas (0.99 = lento, 0.90 = rápido)
    const MIN_RADIUS = 0;     // Radio mínimo para desaparecer
    const SCALE_FACTOR = 0.05; // Ajuste visual del tamaño basado en USD

    // --- ESTADO DE DATOS ---
    // Estructura: { 'BTCUSDT': { value: 50000, side: 'SELL', radius: 50, ... } }
    let dataMap = {}; 
    let nodes = [];
    let simulation;
    let svg, g;
    let width, height;

    // --- INICIALIZACIÓN D3 ---
    function initChart() {
      const container = document.getElementById('bubble-chart');
      width = container.clientWidth;
      height = container.clientHeight;

      svg = d3.select("#bubble-chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      // Grupo principal para centrar
      g = svg.append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

      // Configurar simulación física
      simulation = d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(5)) // Pequeña repulsión
        .force("collide", d3.forceCollide().strength(0.7).radius(d => d.radius + 2)) // Evitar solapamiento
        .force("x", d3.forceX().strength(0.05)) // Gravedad al centro X
        .force("y", d3.forceY().strength(0.05)) // Gravedad al centro Y
        .on("tick", ticked);
      
      // Ajustar tamaño al cambiar ventana
      window.addEventListener('resize', () => {
        width = container.clientWidth;
        height = container.clientHeight;
        svg.attr("width", width).attr("height", height);
        g.attr("transform", `translate(${width / 2},${height / 2})`);
        simulation.alpha(1).restart();
      });

      // Bucle de animación para el decaimiento (Efecto "Memoria")
      setInterval(decayBubbles, 100); 
    }

    // --- FUNCIÓN DE DIBUJADO (TICK) ---
    function ticked() {
      // Unir datos con elementos DOM
      const u = g.selectAll(".node")
        .data(nodes, d => d.id);

      // EXIT: Remover burbujas viejas
      u.exit().transition().duration(500).attr("r", 0).remove();

      // ENTER: Crear nuevas burbujas
      const enter = u.enter().append("g")
        .attr("class", "node");

      enter.append("circle")
        .attr("r", 0) // Empiezan en 0 y crecen
        .attr("fill", d => d.color)
        .transition().duration(300)
        .attr("r", d => d.radius);

      enter.append("text")
        .attr("class", "bubble-label")
        .attr("dy", "-0.2em")
        .text(d => d.id.replace("USDT", ""));

      enter.append("text")
        .attr("class", "bubble-value")
        .attr("dy", "1em")
        .text(d => formatMoney(d.value));

      // UPDATE: Actualizar posiciones y tamaños existentes
      const merged = enter.merge(u);
      
      merged.attr("transform", d => `translate(${d.x},${d.y})`);
      
      merged.select("circle")
        .attr("r", d => d.radius)
        .attr("fill", d => d.color); // Actualizar color si cambia la tendencia
        
      merged.select(".bubble-value")
        .text(d => formatMoney(d.value));
    }

    // --- LÓGICA DE WEBSOCKET ---
    function connectWebSocket() {
      const ws = new WebSocket(WS_URL);
      const statusDot = document.getElementById('connection-status');

      ws.onopen = () => {
        console.log("Conectado a Binance Liquidations");
        statusDot.className = "status-dot status-connected";
      };

      ws.onclose = () => {
        console.log("Desconectado, reintentando...");
        statusDot.className = "status-dot status-disconnected";
        setTimeout(connectWebSocket, 2000);
      };

      ws.onmessage = (event) => {
        const payload = JSON.parse(event.data);
        const liq = payload.o; // Objeto de orden

        if (liq) {
          processLiquidation(liq);
        }
      };
    }

    function processLiquidation(liq) {
      const symbol = liq.s;
      const amountUSD = parseFloat(liq.p) * parseFloat(liq.q);
      const side = liq.S; // BUY o SELL (Side of the LIQUIDATION ORDER)

      // LÓGICA DE COLOR:
      // Si la orden de liquidación es SELL, es porque el usuario tenía un LONG y el precio bajó. (Rojo)
      // Si la orden de liquidación es BUY, es porque el usuario tenía un SHORT y el precio subió. (Verde)
      const color = side === 'SELL' ? '#ff4d4d' : '#2ecc71'; 

      if (!dataMap[symbol]) {
        // Nueva burbuja
        dataMap[symbol] = {
          id: symbol,
          value: 0,
          radius: 0,
          color: color,
          x: 0, 
          y: 0,
          vx: 0, 
          vy: 0
        };
        nodes.push(dataMap[symbol]);
      }

      // Acumular valor (para que la burbuja crezca con liquidaciones consecutivas)
      dataMap[symbol].value += amountUSD;
      // Actualizar color (gana la liquidación más reciente)
      dataMap[symbol].color = color;
      
      // Recalcular radio basado en la raíz cuadrada del valor (para área proporcional)
      updateRadius(dataMap[symbol]);

      // "Calentar" la simulación para que se muevan
      simulation.nodes(nodes);
      simulation.alpha(0.3).restart();
    }

    function updateRadius(node) {
      // Fórmula simple para convertir USD a pixeles de radio
      // Math.sqrt es importante para que el área represente el valor, no el radio
      node.radius = Math.sqrt(node.value) * SCALE_FACTOR;
      
      // Limitar tamaño máximo para que no ocupe toda la pantalla
      if (node.radius > 150) node.radius = 150;
      if (node.radius < 15) node.radius = 15; // Tamaño mínimo legible
    }

    // --- EFECTO DE DECAIMIENTO (Memory Fade) ---
    function decayBubbles() {
      let needsUpdate = false;
      
      // Filtramos nodos que se han vuelto muy pequeños
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        
        // Reducir el valor acumulado un X% cada ciclo
        node.value *= DECAY_RATE;
        updateRadius(node);

        // Si el valor es muy bajo, eliminar del array
        if (node.value < 1000) { // Umbral de $1000 USD
           delete dataMap[node.id];
           nodes.splice(i, 1);
           needsUpdate = true;
        }
      }

      // Si hubo cambios o simplemente para animar la reducción de tamaño:
      simulation.nodes(nodes);
      simulation.alpha(0.05).restart(); // Movimiento ligero
    }

    // --- UTILIDADES ---
    function formatMoney(amount) {
      if (amount >= 1000000) return `$${(amount / 1000000).toFixed(1)}M`;
      if (amount >= 1000) return `$${(amount / 1000).toFixed(0)}K`;
      return `$${amount.toFixed(0)}`;
    }

    // --- ARRANQUE ---
    document.addEventListener('DOMContentLoaded', () => {
      initChart();
      connectWebSocket();
    });

  </script>
</body>
</html>
